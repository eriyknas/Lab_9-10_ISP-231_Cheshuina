# Лабораторная работа №9-12: Продвинутое ООП на Kotlin
## Описание
Лабораторная работа посвящена изучению продвинутых концепций объектно-ориентированного
программирования в Kotlin.
## Структура проекта
Проект содержит примеры реализации продвинутых механизмов ООП, а также пояснения к ключевым
концепциям.
## Как запустить проект
1. Клонируйте репозиторий:
```bash
git clone <URL_репозитория>
```
2. Откройте проект в IntelliJ IDEA.
3. Запустите любой пример через контекстное меню или напрямую из `main`.
## Автор
[Антонова П.А., Чешуина А.Д.]
## Лицензия
Проект создан в учебных целях.
# Геттеры и сеттеры
## Свойства в Kotlin
Свойства — это логическая комбинация поля (field) + геттер + сеттер.
По умолчанию у var есть и getter, и setter, у val — только getter.
## Зачем нужны кастомные геттеры/сеттеры?
1. Проверка условий (валидация)
2. Ограничение диапазонов
3. Логирование
4. Динамический пересчёт значения в getter.
## Пример сеттера
```bash
var health: Int = 100
  set(value) {
    field = value.coerceIn(0, 100)
  }
```
## Пример геттера
```bash
var stamina: Int = 50
  get() = field + 10
```
## Важныймомент: field
Это скрытое автоматически созданное хранилище данных. Внутри
геттера/сеттера только оно хранит фактическое значение свойства.
# Инкапсуляция
## Теория
Инкапсуляция — это принцип ООП, который скрывает внутреннее
состояние объекта и позволяет управлять доступом к нему — чтобы нельзя было
случайно присвоить неправильные данные.
## Kotlin реализует инкапсуляцию с помощью:
1. модификаторов доступа (private, protected, internal, public)
2. кастомных геттеров и сеттеров
3. делегирования свойств (lazy, observable)
#  Data-классы
## Теория
Data-класс (класс данных) — это специальный тип класса в Kotlin,
предназначенный в первую очередь для хранения данных. Основное преимущество
data-классов — автоматическая генерация стандартных методов, которые обычно
приходится писать вручную.
## Основные характеристики и ограничения:
1. Обязательный параметр: Data-класс должен иметь хотя бы один параметр в
   первичном конструкторе;
2. Не обеспечивается на уровне языка, а является рекомендацией: Свойства
   обычно объявляются как val (рекомендуется), но можно использовать var;
3. Наследование: Data-классы не могут быть унаследованы от других классов
   (кроме от Any);
4. Области применения: DTO (Data Transfer Objects), модели данных, сущности,
   настройки, конфигурации.
## Пример data-класса
```bash
data class Item(
  val id: Int,
  val name: String,
  val quantity: Int
)
```
# Абстрактные классы
Абстрактный класс — это базовый класс, от которого нельзя создать объект
напрямую. Он используется для описания общей логики и структуры для группы
связанных классов.
## Может содержать:
1. обычные методы среализацией
2. абстрактные методы (без реализации)
3. свойства (абстрактные и обычные)
## Используется, когда нужно:
1. общее поведение и состояние
2. базовый класс для иерархии объектов
## Пример абстрактного класса
```bash
abstract class Human(val name: String){
  fun hello(){
    println("My name is $name")
  }
}
```
# Интерфейсы
Интерфейс — это контракт поведения, который класс обязуется реализовать.
## Особенности:
1. не хранит состояние
2. может содержать default-реализацию методов
3. один класс может реализовывать несколько интерфейсов
## Пример интерфейса
```bash
interface Movable {}
class Car: Movable {}
```
# Sealed-классы
Sealed-классы (изолированные классы) — это специальный тип классов,
которые ограничивают наследование. Они позволяют определить закрытую
иерархию классов, где все возможные подклассы известны на этапе компиляции.
## Основные характеристики:
1. Ограниченное наследование — можно наследовать только внутри того же
файла или того же пакета;
2. Все подклассы известны — компилятор знает всех возможных наследников;
3. Нельзя создать экземпляр самого sealed-класса (он абстрактный);
4. Идеально для представления ограниченного набора вариантов.
## Пример sealed-класса
```bash
sealed class NetworkResult{
}
```
# Object в Kotlin
Object в Kotlin — это объявление синглтона, который существует только в
одном экземпляре. Это как книга, у которой есть только одна копия в мире. Все, кто
хочет прочитать эту книгу, читают одну и ту же.
##  Представьте:
1. Обычный класс — это чертеж дома. По одному чертежу можно построить
много домов.
2. Object — это конкретный уникальный дом, который уже построен (например,
Московский Кремль). Он один, и больше таких нет.
## Пример object
```bash
object Gamesession{
  init{
    println("Игровая сессия создана")
  }
}
```
# Делегирование свойств
В Kotlin делегирование свойств — это отдельная мощная фича, которая
отличается от делегирования интерфейсов. Она позволяет вынести логику получения
и установки значения свойства в отдельный объект, который называется делегатом.
## Пример делегирования свойств
```bash
var counter: Int by Delegates.observable(0){ _, old, new ->
     println("Счетчик изменился: $old -> $new")
 }
```
# lazy
Lazy позволяет инициализировать объект только при первом обращении к нему.
## Это полезно, если:
1. объект создаётся не всегда
2. его создание ресурсоёмкое
3. нужно отложить инициализацию
## Пример lazy
```bash
val resourceManager by lazy {
  ResourceManager()
}
```
# Observer-паттерн (наблюдатель)
Observer-паттерн позволяет объектам реагировать на изменения состояния другого объекта.
## Впроекте Galaxy Outpost Manager наблюдатели могут:
1. реагировать на изменение ресурсов
2. логировать события
3. уведомлять пользователя
## Пример 
1. ResourceManager изменяет ресурсы, наблюдатель выводит сообщение в консоль при изменении
2. Сохранение состояния, для сохранения состояния проекта используется сериализация в JSON
## Это позволяет:
1. сохранять данные между запусками программы
2. хранить состояние в человекочитаемом формате
3. легко перенести логику в Android-приложение